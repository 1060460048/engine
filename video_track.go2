package engine

import (
	"github.com/Monibuca/utils/v3/go2"
	"github.com/pion/rtp"
	"log"
	"time"
)

type VideoTrack struct {
	FirstScreen byte //最近的关键帧位置，首屏渲染
	Buffer *go2.Ring[rtp.Packet]
	SPS []byte
	PPS []byte
	Info struct {
		PacketCount int
		CodecID     byte
		SPSInfo     SPSInfo
		BPS         int
		lastIndex   byte
		GOP         int //关键帧间隔
	}
	RtmpTag []byte //为rtmp协议缓存的序列帧
}
func (vt *VideoTrack) GetBPS(payloadLen int){
	lastTimestamp := vt.Buffer.GetAt(vt.Info.lastIndex).Timestamp
	if lastTimestamp > 0 && lastTimestamp != vt.Buffer.Current.Timestamp {
		vt.Info.BPS = payloadLen * 1000 / int(vt.Buffer.Current.Timestamp-lastTimestamp)
	}
	vt.Info.lastIndex = vt.Buffer.Index
}

// PushVideo 来自发布者推送的视频
func (vt *VideoTrack) Push(timestamp uint32, payload []byte) {
	payloadLen := len(payload)
	if payloadLen < 3 {
		return
	}
	video := r.VideoRing
	video.Type = FLV_TAG_TYPE_VIDEO
	video.Timestamp = timestamp
	video.Payload = payload
	videoFrameType := payload[0] >> 4       // 帧类型 4Bit, H264一般为1或者2
	r.VideoInfo.CodecID = payload[0] & 0x0f // 编码类型ID 4Bit, JPEG, H263, AVC...
	video.IsSequence = videoFrameType == 1 && payload[1] == 0
	video.IsKeyFrame = videoFrameType == 1 || videoFrameType == 4
	r.VideoInfo.PacketCount++
	video.Number = r.VideoInfo.PacketCount
	if r.VideoTag == nil {
		if video.IsSequence {
			r.setH264Info(video)
		} else {
			log.Println("no AVCSequence")
		}
	} else {
		//更换AVCSequence
		if video.IsSequence {
			r.setH264Info(video)
		}
		if video.IsKeyFrame {
			if r.FirstScreen == nil {
				defer close(r.WaitPub)
				r.FirstScreen = video.Clone()
			} else {
				oldNumber := r.FirstScreen.Number
				r.FirstScreen.GoTo(video.Index)
				r.VideoInfo.GOP = r.FirstScreen.Number - oldNumber
			}
		}
		if !r.UseTimestamp {
			video.Timestamp = uint32(time.Since(r.StartTime) / time.Millisecond)
		}

		video.NextW()
	}
}
